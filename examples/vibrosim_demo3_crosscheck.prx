<?xml version='1.0' encoding='UTF-8'?>
<prx:processinginstructions xmlns="http://limatix.org/processtrak/processinginstructions" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://limatix.org/datacollect"  xmlns:dcv="http://limatix.org/dcvalue" xmlns:prx="http://limatix.org/processtrak/processinginstructions">
  <!-- This file specifies the multi-step processing instructions
  for a VibroSim simulation. In this case we are simulating broadband 
  coupled linear excitation. -->

  <!-- This example also demonstrates the use of submeasurements 
       and using the <prx:elementmatch> element to select which 
       elements a particular step operates on. Specifically, in the
       experiment log there are two new <dc:submeas> elements 
       within the <dc:measurement> element, distinguished by their
       <dc:heatcalctype> subelements. 

       The later steps select precisely which elements to operate
       on with <prx:elementmatch>. The 
       calc_heating_singlefrequency step runs only on the sub-
       measurement with dc:heatcalctype of "singlefrequency" and
       the calc_singlefrequency_motion and calc_heating_welder
       steps only run on the sub-measurement with dc:heatcalctype
       of "welder". The heatflow_analysis step operates on 
       both sub-elements, and if the calculations work correctly
       should give nearly identical heating for both sub-
       measurements. 

       In the first case (heatcalctype "singlefrequency" the 
       single frequency calculation is used directly to evaluate
       heating power for a tone burst of the specified envelope.
       In the second case, an explicit vibration waveform is 
       created instead, of the same format generated by the 
       ultrasonic welder model. Then the heat generated by 
       the vibration is calculated. 

       In either case the power-vs-time profile is stored in the
       [sub-measident]_heatingdata.csv output file, and then
       COMSOL heat flow calculations are performed on each. 
       Obviously the two calculations should give essentially 
       the same amount of heating. 
  -->
  <prx:inputfiles>
    <!-- The <inputfile> tag is where you refer to the "experiment log"
    with one or more sets of simulation parameters -->
    <prx:inputfile xlink:href="vibrosim_demo3_crosscheck.xlg"/>
  </prx:inputfiles>

  <prx:elementmatch>dc:measurement</prx:elementmatch>

  <prx:step name="dummyoutput" descr="Create dummy heating output needed by COMSOL model">
    <prx:script name="vibrocomsol_createdummyoutput.py"/>
  </prx:step>

  <!-- Build the COMSOL model -->
  <prx:step name="buildmodel" descr="Construct COMSOL model">
    <prx:script xlink:href="vibrosim_demo3_comsol.m"/>
  </prx:step>


  <!-- Run the modal analysis -->
  <prx:step name="runmodal">
    <prx:script name="vibrocomsol_runmodal_comsol.m"/>
  </prx:step>

  <prx:step name="synthetic_spectrum">
    <prx:script name="vibrosim_synthetic_spectrum.py"/>
  </prx:step>

  <!-- Typically you will run the above steps, looking at the output of
       synthetic_spectrum (either as an image in the output directory or
       by running the last step with the -i (interactive) option. 
       Compare the synthetic spectrum to a known impulse response
       spectrum and adjust the dc:spcrayleighdamping_alpha and 
       dc:spcrayleighdamping_beta parameters in the experiment log so 
       that the damping (resonant pulse widths) matches the physical 
       system. Increasing dc:spcrayleighdamping_alpha will increase
       damping at low frequencies. Increasing dc:spcrayleighdamping_beta
       will increase damping at high frequencies -->
  
  <prx:step name="entersweepfreqs">
    <prx:script name="vibrocomsol_entersweepfreqs.py"/>
  </prx:step>

  <!-- Set the COMSOL sweep parameter -->
  <prx:step name="setsweepfrequencies">
    <prx:script name="vibrocomsol_setsweepfrequencies_comsol.m"/>
  </prx:step>

  <prx:step name="sweep_analysis">
    <prx:script name="vibrocomsol_sweep_analysis_comsol.m"/>
  </prx:step>

  <!-- Enter a burst frequency -->
  <prx:step name="enterburstfreq">
    <prx:script name="vibrocomsol_enterburstfreq.py"/>
  </prx:step>


  <!-- Fourth step is to set the COMSOL parameter -->
  <prx:step name="setburstfrequency">
    <prx:script name="vibrocomsol_setburstfrequency_comsol.m"/>
  </prx:step>

  <!-- Next step is to run the harmonic burst analysis -->
  <prx:step name="burst_analysis">
    <prx:script name="vibrocomsol_burst_analysis_comsol.m"/>
  </prx:step>


  <!-- This example also illustrates how to run multiple sub-tests
  with different parameters and different subsets of steps. 
  The experiment log has several <dc:submeas> elements, each
  defining an alternative parameter set. 

  All of the .prx steps from the relevant fork-point on 
  then need to have their <prx:elementmatch> set to
  <prx:elementmatch>dc:measurement/dc:submeas</prx:elementmatch>
  or a constrained subset of that. That way all of those
  steps put their output with the submeasurement
  (the previous steps' output will be accessible because it
  is in the parent elements)
  -->

  <!-- 
  In this case on dc:submeas[heatcalctype='singlefrequency'] 
  we do the normal single frequency heating calculation
  --> 
  <prx:step name="eval_closure_state_from_tip_positions">
    <prx:script name="vibrosim_eval_closure_state_from_tip_positions.py"/>
  </prx:step>

  <prx:step name="calc_heating_singlefrequency">
    <prx:elementmatch>dc:measurement/dc:submeas[dc:heatcalctype='singlefrequency']</prx:elementmatch>
    <prx:script name="vibrosim_calc_heating_singlefrequency.py"/>
  </prx:step>
  <!--
      In this case on dc:submeas[heatcalctype='welder'] 
      we use vibrosim_calc_singlefrequency_motion.py to create 
      a motion file and then vibrosim_calc_heating_welder.py 
      to evaluate the heating based on the motion file.
  -->

  <prx:step name="calc_singlefrequency_motion">
    <prx:elementmatch>dc:measurement/dc:submeas[dc:heatcalctype='welder']</prx:elementmatch>
    <prx:script name="vibrosim_calc_singlefrequency_motion.py"/>
  </prx:step>
  <prx:step name="calc_heating_welder">
    <prx:elementmatch>dc:measurement/dc:submeas[dc:heatcalctype='welder']</prx:elementmatch>
    <prx:script name="vibrosim_calc_heating_welder.py"/>
  </prx:step>

  <!-- Finally we run the heatflow analysis. This runs on all sub-measurements -->
  <prx:step name="heatflow_analysis">
    <prx:elementmatch>dc:measurement/dc:submeas</prx:elementmatch>
    <prx:script name="vibrocomsol_heatflow_analysis_comsol.m"/>
  </prx:step>


</prx:processinginstructions>

