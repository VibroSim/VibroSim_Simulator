<?xml version='1.0' encoding='UTF-8'?>
<prx:processinginstructions xmlns="http://limatix.org/processtrak/processinginstructions" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://limatix.org/datacollect"  xmlns:dcv="http://limatix.org/dcvalue" xmlns:prx="http://limatix.org/processtrak/processinginstructions">
  <!-- Idea: Address inability to deal with multiple coupled experiment logs
       by being able to put inputfiles into different classes (class 
       attribute). Then in the elementmatch you can select which experiment 
       log to operate on with a class attribute there. -->
       
  <prx:inputfiles>
    <!-- The <inputfiles> element is where you specify the input
	 experiment logs. These can be XML, or they can be .xls
	 or .xlsx spreadsheets (detected by filename extension).
	 In this case, any <dc:> tags you place within the
	 <inputfile> element will be placed in a <dc:summary>
	 tag of the outputfile -->
    <prx:inputfile xlink:href="vibrosim_demo3.xlg"/>
  </prx:inputfiles>

  <prx:elementmatch>dc:measurement</prx:elementmatch>

  <prx:step name="dummyoutput" descr="Create dummy heating output needed by COMSOL model">
    <prx:script>
      <prx:pycode><![CDATA[ 
import os
import os.path

try:
    # py2.x
    from urllib import pathname2url
    from urllib import url2pathname
    from urllib import quote
    from urllib import unquote
    pass
except ImportError:
    # py3.x
    from urllib.request import pathname2url
    from urllib.request import url2pathname
    from urllib.parse import quote
    from urllib.parse import unquote
    pass

from limatix.dc_value import hrefvalue as hrefv

def run(dc_dest_href,dc_measident_str):

    heatingdata_href = hrefv(quote(dc_measident_str+"_heatingdata.txt"),dc_dest_href)
    
    heatingdatapath = heatingdata_href.getpath()

    # Create directory if needed
    if not os.path.exists(os.path.split(heatingdatapath)[0]):
        os.mkdir(os.path.split(heatingdatapath)[0])
        pass

    fh = open(heatingdatapath,"w")
    fh.write("% t(s) \t r(m) \t side1_heating(W/m^2) \t side2_heating(W/m^2)\n")
    fh.write("0\t0\t0\t0\n")
    fh.close()
    return { "dc:heatingdata": heatingdata_href }
      ]]></prx:pycode>
    </prx:script>

  </prx:step>

  <!-- First step is to build the COMSOL model -->
  <prx:step name="buildmodel" descr="Construct COMSOL model">
    <prx:script xlink:href="vibrosim_demo3_comsol.m"/>
  </prx:step>


  <!-- Second step is to run the modal analysis -->
  <prx:step name="runmodal">
    <prx:script>
      <prx:comsolmatlabcode><![CDATA[ 
% function [ ret ] = runmodal(dc_model_comsol_href)

modelfile = dc_model_comsol_href{1};
model=mphload(modelfile);

% Run the modal study
model.study('solidmech_modal_study').run;

% Determine filename for modal results

[modelpath,modelname,modelext] = fileparts(modelfile);
modal_export_name=fullfile(modelpath,[ modelname '_modalfreq.txt' ]);

model.result.export('solidmech_modal_export').set('filename',buildabspath(modal_export_name));
model.result.export('solidmech_modal_export').run();

% Save .mph output in temporary directory in case use wants to load it back in
savefilename = fullfile(tempdir,sprintf('vibrosim_%s',char(java.lang.System.getProperty('user.name'))),[ modelname '_modalcalc.mph' ]);
mphsave(model,savefilename); 

ret={ 
  { 'dc:modalfreqs', {modal_export_name} },
};


	]]></prx:comsolmatlabcode>
    </prx:script>
  </prx:step>


  <prx:step name="entersweepfreqs">
    <prx:script>
      <prx:pycode><![CDATA[ 
import sys
import numpy as np

from limatix.dc_value import numericunitsvalue as numericunitsv
from VibroSim_Simulator import format_modes
from VibroSim_Simulator import enter_frequency


def run(_xmldoc,_element, dc_modalfreqs_href):

    format_modes.print_comsol_modes(dc_modalfreqs_href.getpath())


    print("\n")


    startfreq = enter_frequency.enter_frequency(_xmldoc,_element,"sweep start","dc:sweep_start_frequency")
    stepfreq = enter_frequency.enter_frequency(_xmldoc,_element,"sweep step","dc:sweep_step_frequency")
    endfreq = enter_frequency.enter_frequency(_xmldoc,_element,"sweep end","dc:sweep_end_frequency")

    return { 
      "dc:sweep_start_frequency": numericunitsv(startfreq,"Hz"), 
      "dc:sweep_step_frequency": numericunitsv(stepfreq,"Hz"), 
      "dc:sweep_end_frequency": numericunitsv(endfreq,"Hz"), 
    }
      ]]></prx:pycode>
    </prx:script>
  </prx:step>

  <!-- Set the COMSOL sweep parameter -->
  <prx:step name="setsweepfrequencies">
    <prx:script>
      <prx:comsolmatlabcode><![CDATA[ 
% function [ ret ] = setsweepfrequencies(dc_model_comsol_href,dc_sweep_start_frequency_float,dc_sweep_step_frequency_float,dc_sweep_end_frequency_float)

modelfile = dc_model_comsol_href{1};
model=mphload(modelfile);

model.param.set('simulationfreqstart',[ to_string(dc_sweep_start_frequency_float) '[Hz]' ]);
model.param.set('simulationfreqstep',[ to_string(dc_sweep_step_frequency_float) '[Hz]' ]);
model.param.set('simulationfreqend',[ to_string(dc_sweep_end_frequency_float) '[Hz]' ]);

[modelpath,modelname,modelext] = fileparts(modelfile);

model_comsol_withsweepfrequencies_name = fullfile(modelpath,[ modelname '_withsweepfrequencies.mph' ]);


mphsave(model,model_comsol_withsweepfrequencies_name); 


ret={ 
  { 'dc:model_comsol_withsweepfrequencies', {model_comsol_withsweepfrequencies_name} }
};


	]]></prx:comsolmatlabcode>
    </prx:script>
  </prx:step>

  <prx:step name="sweep_analysis">
    <prx:script>
      <prx:comsolmatlabcode><![CDATA[ 
% function [ ret ] = sweep_analysis(dc_model_comsol_withsweepfrequencies_href)

modelfile = dc_model_comsol_withsweepfrequencies_href{1};
model=mphload(modelfile);


% Determine filename for harmonic sweep results

[modelpath,modelname,modelext] = fileparts(modelfile);
spectrum_image_name=fullfile(modelpath,[ modelname '_sweep_spectrum.png' ]);


CreateOrReplace(model.result.export,'vibro_harmonicsweep_spectrum_image','vibro_harmonicsweep_spectrum','Image1D');
model.result.export('vibro_harmonicsweep_spectrum_image').label('vibro_harmonicsweep_spectrum_image');
model.result.export('vibro_harmonicsweep_spectrum_image').set('pngfilename',buildabspath(spectrum_image_name));
%model.result.export('vibro_harmonicsweep_spectrum_image').run();


% Run the harmonic study
model.study('solidmech_harmonicsweep_study').run;


% Save .mph output in temporary directory in case use wants to load it back in
savefilename = fullfile(tempdir,sprintf('vibrosim_%s',char(java.lang.System.getProperty('user.name'))),[ modelname '_harmonicsweep.mph' ]);
mphsave(model,savefilename); 

% run the plot/export
model.result('vibro_harmonicsweep_spectrum').run();
model.result.export('vibro_harmonicsweep_spectrum_image').run();

ret={ 
  { 'dc:sweep_spectrum', {spectrum_image_name} },
};

	]]></prx:comsolmatlabcode>
    </prx:script>
  </prx:step>

  <!-- Enter a burst frequency -->
  <prx:step name="enterburstfreq">
    <prx:script>
      <prx:pycode><![CDATA[ 
import sys
import traceback
import numpy as np

from limatix.dc_value import numericunitsvalue as numericunitsv

from VibroSim_Simulator import format_modes
from VibroSim_Simulator import enter_frequency

def run(_xmldoc,_element, dc_modalfreqs_href):

    format_modes.print_comsol_modes(dc_modalfreqs_href.getpath())

    print("\n")

    # Extract prior value of dc:excitation_frequency with noprovenance as default
    freq = enter_frequency.enter_frequency(_xmldoc,_element,"burst","dc:excitation_frequency")

    return { "dc:excitation_frequency": numericunitsv(freq,"Hz") }
      ]]></prx:pycode>
    </prx:script>
  </prx:step>


  <!-- Fourth step is to set the COMSOL parameter -->
  <prx:step name="setburstfrequency">
    <prx:script>
      <prx:comsolmatlabcode><![CDATA[ 
% function [ ret ] = setburstfrequency(dc_model_comsol_href,dc_excitation_frequency_float)

modelfile = dc_model_comsol_href{1};
model=mphload(modelfile);

model.param.set('simulationburstfreq',[ to_string(dc_excitation_frequency_float) '[Hz]' ]);

[modelpath,modelname,modelext] = fileparts(modelfile);

model_comsol_withburstfrequency_name = fullfile(modelpath,[ modelname '_withburstfrequency.mph' ]);


mphsave(model,model_comsol_withburstfrequency_name); 


ret={ 
  { 'dc:model_comsol_withburstfrequency', {model_comsol_withburstfrequency_name} }
};


	]]></prx:comsolmatlabcode>
    </prx:script>
  </prx:step>


  <!-- Next step is to run the harmonic burst analysis -->
  <prx:step name="burst_analysis">
    <prx:script>
      <prx:comsolmatlabcode><![CDATA[ 
% function [ ret ] = burst_analysis(dc_model_comsol_withburstfrequency_href)

modelfile = dc_model_comsol_withburstfrequency_href{1};
model=mphload(modelfile);

% Run the harmonic burst study
model.study('solidmech_harmonicburst_study').run;

[normalstrain,shearstrain]=CrackStrain(model,'Geom','crack','solidmech_harmonicburst',1);

% Determine filename for harmonic results

[modelpath,modelname,modelext] = fileparts(modelfile);
%modal_export_name=fullfile(modelpath,[ modelname '_modalfreq.txt' ]);

%model.result.export('solidmech_modal_export').set('filename',buildabspath(modal_export_name));
%model.result.export('solidmech_modal_export').run();

% Save .mph output in temporary directory in case use wants to load it back in
savefilename = fullfile(tempdir,sprintf('vibrosim_%s',char(java.lang.System.getProperty('user.name'))),[ modelname '_burstcalc.mph' ]);
mphsave(model,savefilename); 

ret={ 
  { 'dc:harmonicburst_normalstrain', normalstrain },
  { 'dc:harmonicburst_shearstrain', shearstrain },
};

	]]></prx:comsolmatlabcode>
    </prx:script>
  </prx:step>

  <prx:step name="calc_heating">
    <prx:script>
      <prx:pycode><![CDATA[ 
import sys
import numpy as np
import sys
import os
import os.path
import tempfile
import scipy 
import numpy as np
from matplotlib import pyplot as pl

try:
    # py2.x
    from urllib import pathname2url
    from urllib import url2pathname
    from urllib import quote
    from urllib import unquote
    pass
except ImportError:
    # py3.x
    from urllib.request import pathname2url
    from urllib.request import url2pathname
    from urllib.parse import quote
    from urllib.parse import unquote
    pass

from limatix.dc_value import hrefvalue as hrefv
from limatix.dc_value import numericunitsvalue as numericunitsv


from crackclosuresim2 import inverse_closure
from crackclosuresim2 import crackopening_from_tensile_closure
from crackclosuresim2 import solve_normalstress

from crackclosuresim2 import ModeI_throughcrack_CODformula
from crackclosuresim2 import Tada_ModeI_CircularCrack_along_midline
from crackclosuresim2 import ModeII_throughcrack_CSDformula
from crackclosuresim2.fabrikant import Fabrikant_ModeII_CircularCrack_along_midline

from angled_friction_model.angled_friction_model import angled_friction_model
from angled_friction_model.angled_friction_model import integrate_power



from limatix.dc_value import numericunitsvalue as numericunitsv


def run(_xmldoc,_element, 
        dc_dest_href,
        dc_measident_str,
        dc_friction_coefficient_float,
	dc_msqrtR_numericunits,
	dc_staticload_numericunits,
        dc_exclength_numericunits,
	dc_tortuosity_numericunits,
	dc_numdraws_int,
	dc_YoungsModulus_numericunits,
	dc_PoissonsRatio_float,
	dc_YieldStrength_numericunits,
	dc_Density_numericunits,
	dc_reff_side1_array, # NOTE: arrayvalue class is not unit-aware!
	dc_seff_side1_array, 
	dc_reff_side2_array,
	dc_seff_side2_array,
	dc_exc_t0_numericunits,
	dc_exc_t1_numericunits,
	dc_exc_t2_numericunits,
	dc_exc_t3_numericunits,
	dc_excitation_frequency_numericunits,
        dc_harmonicburst_normalstrain_complex, 
        dc_harmonicburst_shearstrain_complex):

    verbose=False
    doplots=False


    # Manually extract dc_heatingdata_href so we can do it with no provenance
    dc_heatingdata_el = _xmldoc.xpathsinglecontext(_element,"dc:heatingdata")
    dc_heatingdata_href=hrefv.fromxml(_xmldoc,dc_heatingdata_el)

    t=np.linspace(dc_exc_t0_numericunits.value('s'),dc_exc_t3_numericunits.value('s'),100)
    
    friction_coefficient = dc_friction_coefficient_float
    msqrtR = dc_msqrtR_numericunits.value("m^-1.5")
    static_load = dc_staticload_numericunits.value("Pa")

    plane_stress_modulus = dc_YoungsModulus_numericunits.value("Pa")/(1.0-dc_PoissonsRatio_float**2.0)
    shear_modulus = dc_YoungsModulus_numericunits.value("Pa")/(2.0*(1.0+dc_PoissonsRatio_float))

    # Note: We are ignoring the phases of the normal and shear strains
    vib_normal_stress_ampl = plane_stress_modulus * abs(dc_harmonicburst_normalstrain_complex)
    vib_shear_stress_ampl = shear_modulus * abs(dc_harmonicburst_shearstrain_complex)

    
    angular_stddev = dc_tortuosity_numericunits.value("degrees")*np.pi/180.0

    sigma_yield = dc_YieldStrength_numericunits.value("Pascals")
    tau_yield = sigma_yield/2.0
    
    #crack_model_normal = ModeI throughcrack_CODformula(E)
    crack_model_normal = Tada_ModeI_CircularCrack_along_midline(dc_YoungsModulus_numericunits.value("Pa"),dc_PoissonsRatio_float)
    #crack_model_shear = ModeII_throughcrack_CSDformula(E,nu)
    crack_model_shear = Fabrikant_ModeII_CircularCrack_along_midline(dc_YoungsModulus_numericunits.value("Pa"),dc_PoissonsRatio_float)


    reff_side1 = dc_reff_side1_array.value()
    seff_side1 = dc_seff_side1_array.value()

    reff_side2 = dc_reff_side2_array.value()
    seff_side2 = dc_seff_side2_array.value()


    # Fully open crack lengths for left and right side
    aside1 = np.max(reff_side1) 
    aside2 = np.max(reff_side2)

    # Desired approximate step size for calculations
    approximate_xstep=25e-6 # 25um

    num_boundary_steps=np.floor((max(aside1,aside2)+approximate_xstep)/approximate_xstep)
    xmax = num_boundary_steps*approximate_xstep  # Maximum position from center to calculate to;
    # should exceed half-crack lengths 

    numsteps = num_boundary_steps-1
    xstep = (xmax)/(numsteps) # Actual step size so that xmax is a perfect multiple of this number

    x_bnd = xstep*np.arange(num_boundary_steps) # Position of element boundaries
    xrange = (x_bnd[1:] + x_bnd[:-1])/2.0 # Position of element centers

    # Determine closure stress field from observed crack length data
    closure_stress_side1=inverse_closure(reff_side1,seff_side1,xrange,x_bnd,xstep,aside1,sigma_yield,crack_model_normal,verbose=verbose)
    
    closure_stress_side2=inverse_closure(reff_side2,seff_side2,xrange,x_bnd,xstep,aside2,sigma_yield,crack_model_normal,verbose=verbose)
    
    
    # Evaluate initial crack opening gaps from extrapolated tensile closure field
    crack_initial_opening_side1 = crackopening_from_tensile_closure(xrange,x_bnd,closure_stress_side1,xstep,aside1,sigma_yield,crack_model_normal)
    
    crack_initial_opening_side2 = crackopening_from_tensile_closure(xrange,x_bnd,closure_stress_side2,xstep,aside2,sigma_yield,crack_model_normal)
    
    # Plot the evaluated closure state
    pl.figure()
    pl.plot(xrange[xrange < aside1]*1e3,closure_stress_side1[xrange < aside1]/1e6,'-',
            reff_side1*1e3,seff_side1/1e6,'x')
    for observcnt in range(len(reff_side1)):        
        (effective_length, sigma, tensile_displ, dsigmaext_dxt) = solve_normalstress(xrange,x_bnd,closure_stress_side1,xstep,seff_side1[observcnt],aside1,sigma_yield,crack_model_normal)
	pl.plot(effective_length*1e3,seff_side1[observcnt]/1e6,'.')
	pass
    pl.grid(True)
    pl.legend(('Closure stress field','Observed crack tip posn','Recon. crack tip posn'),loc="best")
    pl.xlabel('Radius from crack center (mm)')
    pl.ylabel('Stress (MPa)')
    pl.title('Crack closure state')
    
    closure_state_href = hrefv(quote(dc_measident_str+"_closurestate.png"),dc_dest_href)
    pl.savefig(closure_state_href.getpath(),dpi=300)



    # Now calculate crack heating under the given conditions
    (power_per_m2_side1,
     power_per_m2_stddev_side1,
     vibration_ampl_side1) = angled_friction_model(x_bnd,xrange,xstep,
                                                   dc_numdraws_int,
						   dc_YoungsModulus_numericunits.value("Pa"),
						   dc_PoissonsRatio_float,
						   sigma_yield,tau_yield,
						   friction_coefficient,
						   closure_stress_side1,
						   crack_initial_opening_side1,
						   angular_stddev,
						   aside1,
						   static_load,
						   vib_normal_stress_ampl,
						   vib_shear_stress_ampl,
						   dc_excitation_frequency_numericunits.value("Hz"),
						   crack_model_normal,
						   crack_model_shear,
						   1.0,
						   msqrtR,
						   verbose,
						   doplots)
						  
    (power_per_m2_side2,
     power_per_m2_stddev_side2,
     vibration_ampl_side2) = angled_friction_model(x_bnd,xrange,xstep,
                                                   dc_numdraws_int,
						   dc_YoungsModulus_numericunits.value("Pa"),
						   dc_PoissonsRatio_float,
						   sigma_yield,tau_yield,
						   friction_coefficient,
						   closure_stress_side2,
						   crack_initial_opening_side2,
						   angular_stddev,
						   aside2,
						   static_load,
						   vib_normal_stress_ampl,
						   vib_shear_stress_ampl,
						   dc_excitation_frequency_numericunits.value("Hz"),
						   crack_model_normal,
						   crack_model_shear,
						   1.0,
						   msqrtR,
						   verbose,
						   doplots)

    #(totalpower_left, totalpower_stddev_left) = integrate_power(xrange,power_per_m2_left,power_per_m2_left_stddev)
    #(totalpower_right, totalpower_stddev_right) = integrate_power(xrange,power_per_m2_right,power_per_m2_right_stddev)

    #totalpower=totalpower_left + totalpower_right
     
    pl.figure()
    pl.clf()
    pl.plot(-xrange*1e3,power_per_m2_side1/1.e3,'-',
            xrange*1e3,power_per_m2_side2/1.e3,'-',)
    pl.grid()
    pl.xlabel('Radius from center (mm)')
    pl.ylabel('Heating power (kW/m^2)')
    pl.title('Crack power deposition')

    heatpower_href = hrefv(quote(dc_measident_str+"_heatpower.png"),dc_dest_href)
    pl.savefig(heatpower_href.getpath(),dpi=300)

    heatingfh = open(dc_heatingdata_href.getpath(),"w")
    heatingfh.write("% t(s) \t r(m) \t side1_heating(W/m^2) \t side2_heating(W/m^2)\n")

    for tidx in range(t.shape[0]):
        for xidx in range(xrange.shape[0]):
            heatingfh.write("%.8e\t%.8e\t%.8e\t%.8e\n" % (t[tidx],xrange[xidx],power_per_m2_side1[xidx],power_per_m2_side2[xidx]))
            pass
        pass
    heatingfh.close()
            
    

    return { 
      "dc:closureplot": closure_state_href,
      "dc:heatpower": heatpower_href,
      "dc:heatingdata": dc_heatingdata_href,
    }
      ]]></prx:pycode>
    </prx:script>
  </prx:step>
  

  <!-- Finally we run the heatflow analysis -->
  <prx:step name="heatflow_analysis">
    <prx:script>
      <prx:comsolmatlabcode><![CDATA[ 
% function [ ret ] = heatflow_analysis(dc_model_comsol_href)

modelfile = dc_model_comsol_href{1};
model=mphload(modelfile);

% refresh the crack heating function data (from the previous step) from disk
model.func('crack_heatingfunction').refresh;


% Determine filename for heating results

[modelpath,modelname,modelext] = fileparts(modelfile);
heating_image_name=fullfile(modelpath,[ modelname '_heating.png' ]);

CreateOrReplace(model.result.export,'vibro_heating_image','vibro_heating_plot','Image3D');
model.result.export('vibro_heating_image').label('vibro_heating_image');
model.result.export('vibro_heating_image').set('pngfilename',buildabspath(heating_image_name));
%model.result.export('vibro_heating_image').run();


% Run the heatflow study
model.study('heatflow_study').run;

% Save .mph output
savefilename = fullfile(modelpath,[ modelname '_heating.mph' ]);
mphsave(model,savefilename); 

% Run the plot/export
model.result.export('vibro_heating_image').run();


ret={ 
  { 'dc:vibro_heating_image', {heating_image_name} },
  { 'dc:heatflow_comsol', {savefilename} },
};

	]]></prx:comsolmatlabcode>
    </prx:script>
  </prx:step>


</prx:processinginstructions>

